<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>液体玻璃2048 - 经典数字益智游戏 | 在线免费玩</title>
    <meta name="description" content="液体玻璃2048是一款精美的数字益智游戏，支持触屏滑动和键盘操作。挑战你的逻辑思维，合并数字方块达到2048！免费在线游戏，无需下载。">
    <meta name="keywords" content="2048游戏,数字游戏,益智游戏,在线游戏,免费游戏,液体玻璃,触屏游戏,HTML5游戏,数学游戏,逻辑游戏">
    <meta name="author" content="2048 Game Developer">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#667eea">
    <meta name="application-name" content="液体玻璃2048">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="game">
    <meta property="og:title" content="液体玻璃2048 - 经典数字益智游戏">
    <meta property="og:description" content="精美的液体玻璃风格2048游戏，支持多种操作方式，挑战你的智力极限！免费在线游戏，无需下载。">
    <meta property="og:url" content="">
    <meta property="og:site_name" content="液体玻璃2048">
    <meta property="og:locale" content="zh_CN">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="液体玻璃2048 - 经典数字益智游戏">
    <meta name="twitter:description" content="精美的液体玻璃风格2048游戏，支持多种操作方式，挑战你的智力极限！">
    <meta name="twitter:creator" content="@2048game">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y84R0TQR9X"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Y84R0TQR9X');
    </script>

    <!-- 移动端优化 -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="液体玻璃2048">
    
    <!-- 搜索引擎优化 -->
    <link rel="canonical" href="">
    <meta name="format-detection" content="telephone=no">
    
    <!-- 结构化数据 -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Game",
        "name": "液体玻璃2048",
        "description": "液体玻璃2048是一款精美的数字益智游戏，支持触屏滑动和键盘操作。挑战你的逻辑思维，合并数字方块达到2048！",
        "genre": "益智游戏",
        "gamePlatform": ["Web浏览器", "移动设备"],
        "operatingSystem": ["iOS", "Android", "Windows", "macOS", "Linux"],
        "applicationCategory": "Game",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "CNY"
        },
        "author": {
            "@type": "Organization",
            "name": "2048 Game Developer"
        },
        "datePublished": "2024-01-01",
        "inLanguage": "zh-CN",
        "isAccessibleForFree": true,
        "keywords": "2048游戏,数字游戏,益智游戏,在线游戏,免费游戏",
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.8",
            "ratingCount": "1000",
            "bestRating": "5",
            "worstRating": "1"
        }
    }
    </script>
    
    <!-- SVG滤镜定义 -->
    <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
        <defs>
            <!-- 液态玻璃效果滤镜 - 移除扭曲效果 -->
            <filter id="glass-distortion">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="softMap"/>
                <feSpecularLighting in="softMap" surfaceScale="2" specularConstant="0.8" specularExponent="100" lighting-color="white" result="specLight">
                    <fePointLight x="-200" y="-200" z="300"/>
                </feSpecularLighting>
                <feComposite in="specLight" operator="arithmetic" k1="0" k2="0.8" k3="0.8" k4="0" result="litImage"/>
            </filter>
            
            <!-- 合并时的发光效果 - 移除扭曲 -->
            <filter id="liquid-burst" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" result="glow"/>
                <feColorMatrix in="glow" type="matrix" values="1 0 0 0 0.2  0 1 0 0 0.4  0 0 1 0 0.6  0 0 0 1 0"/>
                <feComposite in="SourceGraphic" in2="glow" operator="over"/>
            </filter>

            <!-- 移动时的平滑效果 - 移除扭曲 -->
            <filter id="liquid-flow" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" result="smooth"/>
                <feComposite in="SourceGraphic" in2="smooth" operator="over"/>
            </filter>
        </defs>
    </svg>

    <style>
        /* CSS 变量，用于响应式设计 */
        :root {
            --vh: 100vh;
            --tile-size: 100px;
            --grid-gap: 15px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: url('macos-26.jpg') center center / cover no-repeat fixed, linear-gradient(135deg, #667eea 0%, #764ba2 50%, #48CAE4 100%);
            min-height: 100vh;
            
            /* 防止页面缩放和滚动 */
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            
            /* 防止页面被拖拽 */
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            
            /* 防止文本选择 */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            
            /* 允许垂直滚动以适应内容 */
            overflow-x: hidden;
            overflow-y: auto;
        }

        .container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            padding: 40px 20px 60px 20px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-top: 20px;
        }

        .language-switcher-fixed {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 20px;
            padding: 3px;
            gap: 2px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .background-switcher-fixed {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 20px;
            padding: 8px 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .bg-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            padding: 0;
        }

        .bg-btn:hover {
            color: white;
            transform: scale(1.1);
        }

        /* 背景选择器弹窗 */
        .background-selector-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .background-selector-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .background-selector-title {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .background-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .background-option {
            aspect-ratio: 16/9;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .background-option:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .background-option.active {
            border-color: white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .background-option-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 11px;
            padding: 6px 8px;
            text-align: center;
            font-weight: 500;
        }

        .background-selector-close {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 10px 20px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: block;
            margin: 0 auto;
            outline: none;
        }

        .background-selector-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .lang-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-weight: 500;
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }

        .lang-btn:hover {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.1);
        }

        .lang-btn.active {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-weight: 600;
        }

        h1 {
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            margin: 0;
            line-height: 1.2;
        }

        .score-container {
            display: flex;
            gap: 10px;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 12px 20px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            min-width: 100px;
        }

        .score-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 5px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .main-content {
            position: relative;
            margin: 20px 0;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 20px;
            padding: var(--grid-gap);
            position: relative;
            /* width and height will be set by aspect-ratio */
            width: 100%;
            aspect-ratio: 1 / 1;
        }
        
        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: var(--grid-gap);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            grid-gap: var(--grid-gap);
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }
        
        .tile-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .tile {
            position: absolute;
            width: calc((100% - var(--grid-gap) * 5) / 4);
            height: calc((100% - var(--grid-gap) * 5) / 4);
            
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            
            font-size: 48px;
            transition: top 0.15s ease-out, left 0.15s ease-out;
        }

        .liquidGlass-wrapper {
            background: rgba(127, 205, 205, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transform-style: preserve-3d;
            overflow: hidden;
        }

        .liquidGlass-text {
            position: relative;
            z-index: 2;
        }
        
        .tile-2 { background: rgba(127, 205, 205, 0.4); }
        .tile-4 { background: rgba(129, 195, 215, 0.5); }
        .tile-8 { background: rgba(138, 204, 179, 0.6); }
        .tile-16 { background: rgba(168, 230, 207, 0.6); }
        .tile-32 { background: rgba(127, 205, 205, 0.7); }
        .tile-64 { background: rgba(129, 195, 215, 0.8); }
        .tile-128 { background: rgba(138, 204, 179, 0.9); }
        .tile-256 { background: rgba(168, 230, 207, 1.0); color: white; }
        .tile-512 { background: linear-gradient(135deg, #4a69bd, #6c5ce7); }
        .tile-1024 { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        .tile-2048 { background: linear-gradient(135deg, #a29bfe, #fd79a8); }
        .tile-4096 { background: linear-gradient(135deg, #fd79a8, #ff7675); }

        /* Font size adjustments */
        .tile-128, .tile-256, .tile-512 { font-size: 42px; }
        .tile-1024, .tile-2048, .tile-4096 { font-size: 36px; }

        /* Animations */
        .tile-new {
            animation: tile-new 0.2s ease-out;
        }
        @keyframes tile-new {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        .tile-merged {
            animation: tile-merged 0.2s ease-out;
        }
        @keyframes tile-merged {
            from { transform: scale(0); }
            50% { transform: scale(1.2); }
            to { transform: scale(1); }
        }

        .tile-disappear {
            animation: tile-disappear 0.15s ease-in;
        }
        @keyframes tile-disappear {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0); opacity: 0; }
        }

        .tile-reappear {
            animation: tile-reappear 0.2s ease-out;
        }
        @keyframes tile-reappear {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        .footer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
            padding-bottom: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 12px 24px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: none;
            outline: none;
        }

        .btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .game-instructions {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
        }

        .game-instructions h3 {
            color: white;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }

        .game-instructions p {
            margin-bottom: 15px;
        }

        .game-instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .game-instructions li {
            margin-bottom: 8px;
        }

        .game-instructions strong {
            color: rgba(255, 255, 255, 1);
        }
        
        .instructions {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: center;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .game-message {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
            z-index: 10;
            text-align: center;
            color: #2c3e50;
            padding: 20px;
        }

        .game-message p {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .game-message .restart-button {
             background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 12px 24px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        
        .message-buttons {
            display: flex;
            gap: 10px;
        }

        /* 版权信息样式 */
        .copyright {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            line-height: 1.5;
        }

        .copyright a {
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .copyright a:hover {
            color: white;
            text-decoration: underline;
        }

        .copyright .divider {
            margin: 0 8px;
            opacity: 0.5;
        }

        /* 响应式设计 */
        @media (max-width: 520px) {
            .container { 
                padding: 30px 15px 40px 15px; 
                gap: 20px; 
            }
            .header { 
                padding-top: 10px; 
                margin-bottom: 5px; 
            }
            .language-switcher-fixed {
                top: 15px;
                right: 15px;
                padding: 2px;
            }
            .background-switcher-fixed {
                top: 15px;
                left: 15px;
                padding: 6px 12px;
            }
            .background-selector-panel {
                padding: 20px;
                max-width: 90%;
            }
            .background-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 10px;
            }
            .background-selector-title {
                font-size: 18px;
                margin-bottom: 20px;
            }
            .lang-btn {
                font-size: 11px;
                padding: 5px 10px;
            }
            h1 { 
                font-size: 36px; 
                line-height: 1.1; 
            }
            .score-box { 
                padding: 8px 15px; 
                min-width: 80px;
            }
            .main-content { 
                margin: 15px 0; 
            }
            .footer { 
                gap: 15px; 
                margin-top: 20px; 
            }
            .tile { font-size: 36px; }
            .tile-128, .tile-256, .tile-512 { font-size: 32px; }
            .tile-1024, .tile-2048, .tile-4096 { font-size: 28px; }
            .instructions { font-size: 12px; }
            .game-instructions { font-size: 12px; padding: 15px; }
            .copyright { font-size: 11px; padding: 10px; }
        }

        /* 超小屏幕优化 */
        @media (max-width: 360px) {
            .container { 
                padding: 20px 10px 30px 10px; 
            }
            h1 { 
                font-size: 32px; 
            }
            .score-box { 
                padding: 6px 12px; 
                min-width: 70px;
                font-size: 16px;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- 背景切换按钮 - 固定在屏幕左上角 -->
        <div class="background-switcher-fixed">
            <button class="bg-btn" id="bg-switcher" title="切换背景">🎨</button>
        </div>

        <!-- 语言切换按钮 - 固定在屏幕右上角 -->
        <div class="language-switcher-fixed">
            <button class="lang-btn active" data-lang="zh" id="lang-zh">中文</button>
            <button class="lang-btn" data-lang="en" id="lang-en">EN</button>
        </div>

        <header class="header">
            <h1>2048</h1>
            <div class="score-container">
                <div class="score-box">
                    <div class="score-label" data-i18n="score">SCORE</div>
                    <div class="score" id="score">0</div>
                </div>
                <div class="score-box">
                    <div class="score-label" data-i18n="best">BEST</div>
                    <div class="best-score" id="best-score">0</div>
                </div>
            </div>
        </header>

        <main class="main-content" role="main">
            <div class="game-message" id="game-message" style="display: none;" role="dialog" aria-live="polite">
                <p></p>
                <button class="restart-button">Try Again</button>
            </div>
            
            <section class="game-container" aria-label="2048游戏区域">
                <div class="grid-container" role="grid" aria-label="4x4游戏网格">
                    <div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div>
                    <div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div>
                    <div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div>
                    <div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div><div class="grid-cell" role="gridcell"></div>
                </div>
                
                <div class="tile-container" id="tile-container" aria-live="polite" aria-label="游戏方块容器">
                    <!-- Tiles are dynamically generated here -->
                </div>
            </section>
        </main>

        <footer class="footer" role="contentinfo">
            <div class="instructions" data-i18n="instructions">
                使用方向键或滑动屏幕来移动方块
            </div>
            
            <nav class="controls" role="navigation" aria-label="游戏控制">
                <button class="btn" onclick="game.restart()" aria-label="重新开始游戏" data-i18n="restart">重新开始</button>
                <button class="btn" onclick="game.undo()" id="undoBtn" aria-label="撤销上一步操作"><span data-i18n="undo">撤销</span> (<span id="undoCount">3</span>)</button>
            </nav>
            
            <article class="game-instructions">
                <h2 data-i18n="gameTitle">游戏说明</h2>
                <p data-i18n="gameDescription">2048游戏是一款数字益智游戏，目标是在4x4的方格中，通过滑动方块，使相同数字的方块合并，最终达到2048的数字方块。玩家需要控制方块，将其移动到游戏界面上，当相同数字的方块碰撞时，它们会合并成它们和的数字。</p>
                
                <h3 data-i18n="gameRules">游戏规则</h3>
                <ul>
                    <li><strong data-i18n="initialState">初始状态：</strong><span data-i18n="initialStateDesc">游戏开始时，在4x4的方格中随机生成两个数字2或4。</span></li>
                    <li><strong data-i18n="swipeOperation">滑动操作：</strong><span data-i18n="swipeOperationDesc">玩家可以通过上下左右滑动屏幕，控制方块的移动。</span></li>
                    <li><strong data-i18n="mergeRules">合并规则：</strong><span data-i18n="mergeRulesDesc">当两个相同数字的方块碰撞时，它们会合并成为它们的和。例如，2+2=4，4+4=8。</span></li>
                    <li><strong data-i18n="newTile">生成新方块：</strong><span data-i18n="newTileDesc">每次滑动后，会在空白的方格中随机生成一个2或4。</span></li>
                    <li><strong data-i18n="gameEnd">游戏结束：</strong><span data-i18n="gameEndDesc">当方格全部被填充，并且没有可移动的方块时，游戏结束。</span></li>
                    <li><strong data-i18n="gameGoal">游戏目标：</strong><span data-i18n="gameGoalDesc">游戏的目标是在方格中生成一个数字2048。</span></li>
                    <li><strong data-i18n="gameWin">游戏胜利：</strong><span data-i18n="gameWinDesc">当游戏界面上出现数字2048的方块时，游戏胜利。</span></li>
                </ul>
            </article>
            
            <!-- 版权信息 -->
            <div class="copyright">
                <p>
                    <span data-i18n="copyright">© 2024 液体玻璃2048游戏</span>
                    <span class="divider">|</span>
                    <span data-i18n="basedOn">基于经典2048游戏改编</span>
                    <span class="divider">|</span>
                    <a href="mailto:contact@2048game.com" rel="noopener" data-i18n="contactUs">联系我们</a>
                </p>
                <p>
                    <span data-i18n="freeGame">本游戏完全免费，仅供娱乐学习使用</span>
                    <span class="divider">|</span>
                    <a href="#" onclick="showPrivacyPolicy()" rel="noopener" data-i18n="privacyPolicy">隐私政策</a>
                    <span class="divider">|</span>
                    <a href="#" onclick="showTerms()" rel="noopener" data-i18n="termsOfUse">使用条款</a>
                </p>
                <p>
                    <span data-i18n="supportedBrowsers">支持的浏览器：Chrome, Firefox, Safari, Edge</span>
                    <span class="divider">|</span>
                    <span data-i18n="bestResolution">最佳体验分辨率：1920x1080</span>
                </p>
            </div>
        </footer>
    </div>

    <!-- 背景选择器弹窗 -->
    <div class="background-selector-overlay" id="background-selector">
        <div class="background-selector-panel">
            <h3 class="background-selector-title" data-i18n="selectBackground">选择背景</h3>
            <div class="background-grid" id="background-grid">
                <!-- 背景选项将通过JavaScript动态生成 -->
            </div>
            <button class="background-selector-close" onclick="closeBackgroundSelector()" data-i18n="close">关闭</button>
        </div>
    </div>
    
    <script>
        // 国际化数据
        const i18nData = {
            zh: {
                score: 'SCORE',
                best: 'BEST',
                instructions: '使用方向键或滑动屏幕来移动方块',
                restart: '重新开始',
                undo: '撤销',
                gameTitle: '游戏说明',
                gameDescription: '2048游戏是一款数字益智游戏，目标是在4x4的方格中，通过滑动方块，使相同数字的方块合并，最终达到2048的数字方块。玩家需要控制方块，将其移动到游戏界面上，当相同数字的方块碰撞时，它们会合并成它们和的数字。',
                gameRules: '游戏规则',
                initialState: '初始状态：',
                initialStateDesc: '游戏开始时，在4x4的方格中随机生成两个数字2或4。',
                swipeOperation: '滑动操作：',
                swipeOperationDesc: '玩家可以通过上下左右滑动屏幕，控制方块的移动。',
                mergeRules: '合并规则：',
                mergeRulesDesc: '当两个相同数字的方块碰撞时，它们会合并成为它们的和。例如，2+2=4，4+4=8。',
                newTile: '生成新方块：',
                newTileDesc: '每次滑动后，会在空白的方格中随机生成一个2或4。',
                gameEnd: '游戏结束：',
                gameEndDesc: '当方格全部被填充，并且没有可移动的方块时，游戏结束。',
                gameGoal: '游戏目标：',
                gameGoalDesc: '游戏的目标是在方格中生成一个数字2048。',
                gameWin: '游戏胜利：',
                gameWinDesc: '当游戏界面上出现数字2048的方块时，游戏胜利。',
                youWin: '你赢了!',
                gameOver: '游戏结束',
                noMoves: '无路可走!',
                tryAgain: '再来一局',
                undoAction: '撤销',
                copyright: '© 2024 液体玻璃2048游戏',
                basedOn: '基于经典2048游戏改编',
                contactUs: '联系我们',
                freeGame: '本游戏完全免费，仅供娱乐学习使用',
                privacyPolicy: '隐私政策',
                termsOfUse: '使用条款',
                supportedBrowsers: '支持的浏览器：Chrome, Firefox, Safari, Edge',
                bestResolution: '最佳体验分辨率：1920x1080',
                selectBackground: '选择背景',
                close: '关闭'
            },
            en: {
                score: 'SCORE',
                best: 'BEST',
                instructions: 'Use arrow keys or swipe to move tiles',
                restart: 'New Game',
                undo: 'Undo',
                gameTitle: 'How to Play',
                gameDescription: '2048 is a number puzzle game where the goal is to slide numbered tiles on a 4x4 grid to combine them and create a tile with the number 2048. When two tiles with the same number touch, they merge into one.',
                gameRules: 'Game Rules',
                initialState: 'Initial State:',
                initialStateDesc: 'The game starts with two tiles (2 or 4) randomly placed on the 4x4 grid.',
                swipeOperation: 'Swipe Operation:',
                swipeOperationDesc: 'Players can swipe up, down, left, or right to move all tiles in that direction.',
                mergeRules: 'Merge Rules:',
                mergeRulesDesc: 'When two tiles with the same number collide, they merge into their sum. For example, 2+2=4, 4+4=8.',
                newTile: 'New Tile Generation:',
                newTileDesc: 'After each move, a new tile (2 or 4) appears randomly in an empty spot.',
                gameEnd: 'Game Over:',
                gameEndDesc: 'The game ends when the grid is full and no moves are possible.',
                gameGoal: 'Game Goal:',
                gameGoalDesc: 'The objective is to create a tile with the number 2048.',
                gameWin: 'Victory:',
                gameWinDesc: 'You win when a tile with 2048 appears on the board.',
                youWin: 'You Win!',
                gameOver: 'Game Over',
                noMoves: 'No More Moves!',
                tryAgain: 'Try Again',
                undoAction: 'Undo',
                copyright: '© 2024 Liquid Glass 2048 Game',
                basedOn: 'Based on the classic 2048 game',
                contactUs: 'Contact Us',
                freeGame: 'This game is completely free for entertainment and learning purposes',
                privacyPolicy: 'Privacy Policy',
                termsOfUse: 'Terms of Use',
                supportedBrowsers: 'Supported Browsers: Chrome, Firefox, Safari, Edge',
                bestResolution: 'Best Experience Resolution: 1920x1080',
                selectBackground: 'Select Background',
                close: 'Close'
            }
        };

        // 当前语言
        let currentLanguage = localStorage.getItem('gameLanguage') || 'zh';

        // 国际化函数
        function updateLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('gameLanguage', lang);
            
            // 更新所有带有 data-i18n 属性的元素
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18nData[lang] && i18nData[lang][key]) {
                    element.textContent = i18nData[lang][key];
                }
            });
            
            // 更新语言按钮状态
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`lang-${lang}`).classList.add('active');
            
            // 更新页面标题和meta信息
            if (lang === 'en') {
                document.title = 'Liquid Glass 2048 - Classic Number Puzzle Game | Play Free Online';
                document.querySelector('meta[name="description"]').content = 'Liquid Glass 2048 is a beautiful number puzzle game with touch swipe and keyboard controls. Challenge your logic, merge number tiles to reach 2048! Free online game, no download required.';
            } else {
                document.title = '液体玻璃2048 - 经典数字益智游戏 | 在线免费玩';
                document.querySelector('meta[name="description"]').content = '液体玻璃2048是一款精美的数字益智游戏，支持触屏滑动和键盘操作。挑战你的逻辑思维，合并数字方块达到2048！免费在线游戏，无需下载。';
            }
        }

        // 获取翻译文本
        function t(key) {
            return i18nData[currentLanguage] && i18nData[currentLanguage][key] || key;
        }

        // 全局变量
        let touchStartX = null;
        let touchStartY = null;
        let animationId = null;

        // 背景样式数组
        const backgroundStyles = [
            {
                name: '经典背景',
                nameEn: 'Classic',
                style: "url('macos-26.jpg') center center / cover no-repeat fixed, linear-gradient(135deg, #667eea 0%, #764ba2 50%, #48CAE4 100%)"
            },
            {
                name: '紫蓝梦境',
                nameEn: 'Purple Blue',
                style: "radial-gradient(circle at 80% 80%, rgba(120, 119, 198, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 20% 20%, rgba(72, 202, 228, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 50% 30%, rgba(118, 75, 162, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #667eea 0%, #764ba2 100%)"
            },
            {
                name: '粉橙暖阳',
                nameEn: 'Pink Orange',
                style: "radial-gradient(circle at 30% 70%, rgba(255, 154, 158, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 70% 30%, rgba(250, 208, 196, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 206, 84, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)"
            },
            {
                name: '翠绿海洋',
                nameEn: 'Green Ocean',
                style: "radial-gradient(circle at 60% 40%, rgba(79, 172, 254, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 40% 60%, rgba(0, 242, 96, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 80% 20%, rgba(5, 117, 230, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)"
            },
            {
                name: '紫粉魅惑',
                nameEn: 'Purple Pink',
                style: "radial-gradient(circle at 25% 75%, rgba(168, 85, 247, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 75% 25%, rgba(236, 72, 153, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 50% 50%, rgba(139, 69, 19, 0.2) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #a855f7 0%, #ec4899 100%)"
            },
            {
                name: '金橙火焰',
                nameEn: 'Golden Fire',
                style: "radial-gradient(circle at 90% 10%, rgba(251, 191, 36, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 10% 90%, rgba(249, 115, 22, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 50% 50%, rgba(239, 68, 68, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #fbbf24 0%, #f97316 50%, #ef4444 100%)"
            },
            {
                name: '青蓝清新',
                nameEn: 'Cyan Blue',
                style: "radial-gradient(circle at 40% 80%, rgba(6, 182, 212, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 80% 20%, rgba(59, 130, 246, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 20% 40%, rgba(16, 185, 129, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #06b6d4 0%, #3b82f6 50%, #10b981 100%)"
            },
            {
                name: '深紫神秘',
                nameEn: 'Deep Purple',
                style: "radial-gradient(circle at 60% 60%, rgba(99, 102, 241, 0.4) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 30% 30%, rgba(139, 92, 246, 0.3) 0%, rgba(0, 0, 0, 0) 50%), radial-gradient(circle at 80% 40%, rgba(168, 85, 247, 0.3) 0%, rgba(0, 0, 0, 0) 50%), linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%)"
            }
        ];

        let currentBackgroundIndex = 0;

        // 隐私政策弹窗
        function showPrivacyPolicy() {
            const privacyText = currentLanguage === 'zh' 
                ? '隐私政策：\n\n本游戏不收集任何个人信息，仅在本地存储游戏数据（最高分等）。\n游戏数据仅保存在您的设备上，不会上传到任何服务器。\n我们承诺保护您的隐私安全。'
                : 'Privacy Policy:\n\nThis game does not collect any personal information, only stores game data locally (such as high scores).\nGame data is only saved on your device and is not uploaded to any server.\nWe are committed to protecting your privacy and security.';
            alert(privacyText);
        }

        // 使用条款弹窗
        function showTerms() {
            const termsText = currentLanguage === 'zh'
                ? '使用条款：\n\n1. 本游戏完全免费，仅供娱乐使用\n2. 禁止用于任何商业用途\n3. 请合理安排游戏时间\n4. 如有技术问题，请联系开发者\n5. 本游戏基于开源项目开发'
                : 'Terms of Use:\n\n1. This game is completely free for entertainment use only\n2. Commercial use is prohibited\n3. Please manage your gaming time reasonably\n4. Contact the developer if you have technical issues\n5. This game is based on open source projects';
            alert(termsText);
        }

        // 显示背景选择器
        function showBackgroundSelector() {
            const selector = document.getElementById('background-selector');
            const grid = document.getElementById('background-grid');
            
            // 清空网格
            grid.innerHTML = '';
            
            // 生成背景选项
            backgroundStyles.forEach((bg, index) => {
                const option = document.createElement('div');
                option.className = 'background-option';
                option.style.background = bg.style;
                
                if (index === currentBackgroundIndex) {
                    option.classList.add('active');
                }
                
                const label = document.createElement('div');
                label.className = 'background-option-label';
                label.textContent = currentLanguage === 'zh' ? bg.name : bg.nameEn;
                
                option.appendChild(label);
                option.addEventListener('click', () => selectBackground(index));
                grid.appendChild(option);
            });
            
            selector.style.display = 'flex';
        }

        // 关闭背景选择器
        function closeBackgroundSelector() {
            document.getElementById('background-selector').style.display = 'none';
        }

        // 选择背景
        function selectBackground(index) {
            currentBackgroundIndex = index;
            document.body.style.background = backgroundStyles[index].style;
            localStorage.setItem('backgroundIndex', currentBackgroundIndex);
            
            // 更新选中状态
            document.querySelectorAll('.background-option').forEach((option, i) => {
                option.classList.toggle('active', i === index);
            });
            
            // 延迟关闭选择器，让用户看到选择效果
            setTimeout(() => {
                closeBackgroundSelector();
            }, 300);
        }

        // 初始化背景
        function initBackground() {
            const savedIndex = localStorage.getItem('backgroundIndex');
            if (savedIndex !== null && savedIndex >= 0 && savedIndex < backgroundStyles.length) {
                currentBackgroundIndex = parseInt(savedIndex);
                document.body.style.background = backgroundStyles[currentBackgroundIndex].style;
            }
        }

        class Game2048 {
            constructor() {
                this.size = 4;
                this.grid = [];
                this.score = 0;
                this.bestScore = localStorage.getItem('bestScore') || 0;
                
                // 撤销系统
                this.stateHistory = []; // 历史状态栈
                this.maxHistorySize = 100; // 最多保存100个历史状态
                this.initialUndoCount = 3; // 初始撤销次数
                this.undoCount = this.initialUndoCount; // 当前可用撤销次数
                this.maxUndoCount = 10; // 最大累计撤销次数
                this.undoRewardValue = 256; // 每合成256的倍数获得撤销次数
                
                this.tileContainer = document.getElementById('tile-container');
                this.scoreDisplay = document.getElementById('score');
                this.bestScoreDisplay = document.getElementById('best-score');
                this.messageContainer = document.getElementById('game-message');
                this.undoButton = document.getElementById('undoBtn');
                
                this.startX = 0;
                this.startY = 0;
                this.endX = 0;
                this.endY = 0;
                
                this.tiles = {}; // 保存方块DOM元素的引用
                this.tileId = 0; // 用于生成唯一的方块ID
                
                // 随机数生成器
                this.randomSeed = Date.now(); // 初始种子
                this.random = this.createSeededRandom(this.randomSeed);
                
                // 动画状态标志
                this.isAnimating = false;
                
                this.setup();
                this.updateDisplay();
                
                // 修复iOS视口高度问题
                this.fixViewportHeight();
            }
            
            fixViewportHeight() {
                const setVH = () => {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                };
                setVH();
                window.addEventListener('resize', setVH);
                window.addEventListener('orientationchange', setVH);
            }
            
            setup() {
                for (let i = 0; i < this.size; i++) {
                    this.grid[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.grid[i][j] = null;
                    }
                }
                
                this.addNewTile();
                this.addNewTile();
                
                this.saveState();
                this.setupEventListeners();
                this.bestScoreDisplay.textContent = this.bestScore;
                this.updateUndoButton();
            }
            
            createSeededRandom(seed) {
                let currentSeed = seed;
                return {
                    random: () => {
                        currentSeed = (currentSeed * 1664525 + 1013904223) % 2147483647;
                        return currentSeed / 2147483647;
                    },
                    getSeed: () => currentSeed,
                    setSeed: (newSeed) => {
                        currentSeed = newSeed;
                    }
                };
            }
            
            setupEventListeners() {
                if (!this.keydownHandler) {
                    this.keydownHandler = (e) => {
                        const keyMap = {
                            'arrowleft': 'left', 'a': 'left',
                            'arrowup': 'up', 'w': 'up',
                            'arrowright': 'right', 'd': 'right',
                            'arrowdown': 'down', 's': 'down'
                        };
                        const direction = keyMap[e.key.toLowerCase()];
                        if (direction) {
                            e.preventDefault();
                            this.move(direction);
                        }
                    };
                }
                document.removeEventListener('keydown', this.keydownHandler);
                document.addEventListener('keydown', this.keydownHandler);
                
                let touchStarted = false;
                document.addEventListener('touchstart', (e) => {
                    if (e.target.closest('button')) return;
                    touchStarted = true;
                    this.startX = e.touches[0].clientX;
                    this.startY = e.touches[0].clientY;
                }, { passive: true });
                
                document.addEventListener('touchmove', (e) => {
                    if (touchStarted) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    if (touchStarted) {
                        touchStarted = false;
                        this.endX = e.changedTouches[0].clientX;
                        this.endY = e.changedTouches[0].clientY;
                        this.handleSwipe();
                    }
                }, { passive: true });
                
                let mouseDown = false;
                document.addEventListener('mousedown', (e) => {
                    if (e.target.closest('button')) return;
                    mouseDown = true;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (mouseDown) {
                        this.endX = e.clientX;
                        this.endY = e.clientY;
                        this.handleSwipe();
                        mouseDown = false;
                    }
                });
            }
            
            handleSwipe() {
                const diffX = this.endX - this.startX;
                const diffY = this.endY - this.startY;
                const minSwipeDistance = 30;
                
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (Math.abs(diffX) > minSwipeDistance) {
                        this.move(diffX > 0 ? 'right' : 'left');
                    }
                } else {
                    if (Math.abs(diffY) > minSwipeDistance) {
                        this.move(diffY > 0 ? 'down' : 'up');
                    }
                }
            }
            
            move(direction) {
                if (this.isAnimating) return;
                
                const movements = [];
                const merges = [];
                let moved = false;
                
                const newGrid = Array.from({ length: this.size }, () => Array(this.size).fill(null));
                
                const process = (line, startIndex) => {
                    const result = this.processLine(line, startIndex.row, startIndex.col, startIndex.rowDir, startIndex.colDir);
                    moved = result.moved || moved;
                    movements.push(...result.movements);
                    merges.push(...result.merges);
                    return result.line;
                };

                if (direction === 'left') {
                    for (let row = 0; row < this.size; row++) {
                        const processedLine = process(this.getRow(row), { row, col: 0, rowDir: 0, colDir: 1 });
                        this.setRow(newGrid, row, processedLine);
                    }
                } else if (direction === 'right') {
                    for (let row = 0; row < this.size; row++) {
                        const processedLine = process(this.getRow(row).reverse(), { row, col: 3, rowDir: 0, colDir: -1 });
                        this.setRow(newGrid, row, processedLine.reverse());
                    }
                } else if (direction === 'up') {
                    for (let col = 0; col < this.size; col++) {
                        const processedLine = process(this.getColumn(col), { row: 0, col, rowDir: 1, colDir: 0 });
                        this.setColumn(newGrid, col, processedLine);
                    }
                } else if (direction === 'down') {
                    for (let col = 0; col < this.size; col++) {
                        const processedLine = process(this.getColumn(col).reverse(), { row: 3, col, rowDir: -1, colDir: 0 });
                        this.setColumn(newGrid, col, processedLine.reverse());
                    }
                }
                
                if (moved) {
                    this.isAnimating = true;
                    this.grid = newGrid;
                    
                    this.animateMovements(movements, merges, () => {
                        this.addNewTile();
                        this.saveState();
                        this.updateDisplay();
                        this.isAnimating = false;
                        
                        if (this.checkWin()) {
                            this.showMessage(t('youWin'), 'game-won');
                        } else if (this.checkGameOver()) {
                            if (this.undoCount === 0) {
                                this.showMessage(t('gameOver'), 'game-over');
                            } else {
                                this.showMessage(t('noMoves'), 'game-stuck');
                            }
                        }
                    });
                }
            }
            
            processLine(line, startRow, startCol, rowDir, colDir) {
                const movements = [];
                const merges = [];
                const result = [];
                let moved = false;
                
                const tiles = line.filter(t => t !== null).map((tile, index) => ({ tile, originalIndex: line.indexOf(tile, index) }));

                let i = 0;
                while (i < tiles.length) {
                    const current = tiles[i];
                    const fromPos = {
                        row: startRow + current.originalIndex * rowDir,
                        col: startCol + current.originalIndex * colDir
                    };
                    const toPos = {
                        row: startRow + result.length * rowDir,
                        col: startCol + result.length * colDir
                    };

                    if (fromPos.row !== toPos.row || fromPos.col !== toPos.col) {
                        movements.push({ tile: current.tile, from: fromPos, to: toPos });
                        moved = true;
                    }

                    if (i + 1 < tiles.length && current.tile.value === tiles[i + 1].tile.value && !current.tile.merged) {
                        const next = tiles[i + 1];
                        const mergedTile = { id: this.tileId++, value: current.tile.value * 2, merged: true };
                        
                        const nextFromPos = { row: startRow + next.originalIndex * rowDir, col: startCol + next.originalIndex * colDir };
                        movements.push({ tile: next.tile, from: nextFromPos, to: toPos });
                        
                        merges.push({ tiles: [current.tile, next.tile], result: mergedTile, position: toPos });
                        
                        result.push(mergedTile);
                        this.score += mergedTile.value;
                        moved = true;
                        
                        if (mergedTile.value >= this.undoRewardValue && mergedTile.value % this.undoRewardValue === 0) {
                            this.earnUndoReward();
                        }
                        
                        i += 2;
                    } else {
                        result.push(current.tile);
                        i++;
                    }
                }
                
                while (result.length < this.size) result.push(null);
                
                return { line: result, moved, movements, merges };
            }
            
            getRow(row) { return this.grid[row].slice(); }
            setRow(grid, row, values) { grid[row] = values; }
            getColumn(col) { return this.grid.map(row => row[col]); }
            setColumn(grid, col, values) { values.forEach((val, i) => grid[i][col] = val); }
            
            animateMovements(movements, merges, callback) {
                movements.forEach(movement => {
                    const tile = this.tiles[movement.tile.id];
                    if (tile) {
                        const { top, left } = this.getPosition(movement.to.row, movement.to.col);
                        tile.style.top = top;
                        tile.style.left = left;
                    }
                });
                
                setTimeout(() => {
                    merges.forEach(merge => {
                        merge.tiles.forEach(tile => {
                            if (this.tiles[tile.id]) {
                                this.tiles[tile.id].remove();
                                delete this.tiles[tile.id];
                            }
                        });
                        this.createTileElement(merge.position.row, merge.position.col, merge.result, false, true);
                    });
                    
                    this.updateScoreDisplay();
                    setTimeout(callback, 50);
                }, 150);
            }
            
            addNewTile() {
                const emptyCells = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === null) emptyCells.push({row: i, col: j});
                    }
                }
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(this.random.random() * emptyCells.length)];
                    const value = this.random.random() < 0.9 ? 2 : 4;
                    const newTile = { id: this.tileId++, value, merged: false };
                    this.grid[randomCell.row][randomCell.col] = newTile;
                    this.createTileElement(randomCell.row, randomCell.col, newTile, true, false);
                }
            }
            
            updateDisplay() {
                this.grid.forEach(row => row.forEach(tile => {
                    if (tile) tile.merged = false;
                }));
                this.updateScoreDisplay();
                this.updateUndoButton();
            }
            
            updateScoreDisplay() {
                this.scoreDisplay.textContent = this.score;
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    this.bestScoreDisplay.textContent = this.bestScore;
                    localStorage.setItem('bestScore', this.bestScore);
                }
            }

            earnUndoReward() {
                if (this.undoCount < this.maxUndoCount) this.undoCount++;
            }
            
            updateUndoButton() {
                const undoCountSpan = document.getElementById('undoCount');
                if (undoCountSpan) {
                    undoCountSpan.textContent = this.undoCount;
                }
                this.undoButton.disabled = !(this.undoCount > 0 && this.stateHistory.length > 1);
            }
            
            createTileElement(row, col, tileData, isNew = false, isMerged = false, isReappear = false) {
                const tileWrapper = document.createElement('div');
                tileWrapper.className = `tile liquidGlass-wrapper tile-${tileData.value}`;
                tileWrapper.id = `tile-${tileData.id}`;

                if (isNew) tileWrapper.classList.add('tile-new');
                if (isMerged) tileWrapper.classList.add('tile-merged');
                if (isReappear) tileWrapper.classList.add('tile-reappear');

                const textDiv = document.createElement('div');
                textDiv.className = 'liquidGlass-text';
                textDiv.textContent = tileData.value;
                tileWrapper.appendChild(textDiv);
                
                const { top, left } = this.getPosition(row, col);
                tileWrapper.style.top = top;
                tileWrapper.style.left = left;
                
                this.tileContainer.appendChild(tileWrapper);
                this.tiles[tileData.id] = tileWrapper;
            }
            
            getPosition(row, col) {
                const container = this.tileContainer.getBoundingClientRect();
                const totalGap = (this.size + 1) * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));
                const tileSize = (container.width - totalGap) / this.size;
                const gapSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));

                const left = gapSize + col * (tileSize + gapSize);
                const top = gapSize + row * (tileSize + gapSize);

                return { top: `${top}px`, left: `${left}px` };
            }
            
            checkWin() {
                return this.grid.some(row => row.some(tile => tile && tile.value === 2048));
            }
            
            checkGameOver() {
                if (this.grid.some(row => row.some(tile => tile === null))) return false;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const current = this.grid[i][j];
                        if (j < this.size - 1 && current.value === this.grid[i][j + 1].value) return false;
                        if (i < this.size - 1 && current.value === this.grid[i + 1][j].value) return false;
                    }
                }
                return true;
            }
            
            saveState() {
                const state = {
                    grid: JSON.parse(JSON.stringify(this.grid)),
                    score: this.score,
                    undoCount: this.undoCount,
                    randomSeed: this.random.getSeed(),
                    tileId: this.tileId
                };
                
                if (this.stateHistory.length > 0) {
                    const lastState = this.stateHistory[this.stateHistory.length - 1];
                    if (JSON.stringify(lastState.grid) === JSON.stringify(state.grid)) return;
                }
                
                this.stateHistory.push(state);
                if (this.stateHistory.length > this.maxHistorySize) this.stateHistory.shift();
            }
            
            undo() {
                if (this.isAnimating || this.undoCount <= 0 || this.stateHistory.length <= 1) return;
                
                this.isAnimating = true;
                this.stateHistory.pop();
                const previousState = this.stateHistory[this.stateHistory.length - 1];
                
                this.tileContainer.innerHTML = '';
                this.tiles = {};
                
                this.grid = JSON.parse(JSON.stringify(previousState.grid));
                this.score = previousState.score;
                this.undoCount = previousState.undoCount -1;
                this.random.setSeed(previousState.randomSeed);
                this.tileId = previousState.tileId;
                
                this.grid.forEach((row, i) => {
                    row.forEach((tile, j) => {
                        if (tile) this.createTileElement(i, j, tile, false, false, true);
                    });
                });
                
                this.updateDisplay();
                this.isAnimating = false;
            }
            
            restart() {
                this.tileContainer.innerHTML = '';
                this.tiles = {};
                this.grid = [];
                this.score = 0;
                this.stateHistory = [];
                this.undoCount = this.initialUndoCount;
                this.tileId = 0;
                this.randomSeed = Date.now();
                this.random = this.createSeededRandom(this.randomSeed);
                
                this.hideMessage();
                this.setup();
            }
            
            showMessage(text, className) {
                this.messageContainer.innerHTML = '';
                const p = document.createElement('p');
                p.textContent = text;
                this.messageContainer.appendChild(p);

                this.messageContainer.className = 'game-message ' + className;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'message-buttons';

                if (className === 'game-stuck') {
                    const undoBtn = document.createElement('button');
                    undoBtn.className = 'restart-button';
                    undoBtn.textContent = `${t('undoAction')} (${this.undoCount})`;
                    undoBtn.onclick = () => { this.hideMessage(); this.undo(); };
                    buttonContainer.appendChild(undoBtn);
                }

                const restartBtn = document.createElement('button');
                restartBtn.className = 'restart-button';
                restartBtn.textContent = t('tryAgain');
                restartBtn.onclick = () => game.restart();
                buttonContainer.appendChild(restartBtn);

                this.messageContainer.appendChild(buttonContainer);
                this.messageContainer.style.display = 'flex';
            }
            
            hideMessage() {
                this.messageContainer.style.display = 'none';
                this.messageContainer.className = 'game-message';
            }
        }

        const game = new Game2048();

        // 语言切换事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化语言
            updateLanguage(currentLanguage);
            
            // 初始化背景
            initBackground();
            
            // 添加语言切换按钮事件
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    updateLanguage(lang);
                });
            });
            
            // 添加背景切换按钮事件
            document.getElementById('bg-switcher').addEventListener('click', showBackgroundSelector);
            
            // 点击背景选择器外部区域关闭
            document.getElementById('background-selector').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeBackgroundSelector();
                }
            });
        });
    </script>
</body>
</html>
